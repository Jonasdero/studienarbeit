\chapter{Anforderungen und Problemanalyse}
\label{ch:anforderungen}

Im folgenden Kapitel sollen alle wesentlichen Funktionen des geplanten Prototyps dargestellt werden.
Da es sich um ein kleines Projekt mit einem abgestecktem Rahmen handelt und es kein Team gibt, welches die Entwicklung durchführt, wird das Wasserfallmodell für diese Entwicklung verwendet.\footnote{Vgl. \ref{sec:methods}}


\section{Vorgehensweise}
\label{ref:requirementMethods}
Zur Erfassung der Anforderungen bzw. Requirements Engineering werden User Stories benutzt. Diese sind bekannt aus agilen Softwareentwicklungsmodellen, wie z. B. Scrum, entstanden aber durch praktische Erfahrungen in der Softwareentwicklung.
Konzeptioniert wurden sie von Dr. Ivar Jacobsen\footnote{Vgl. Jacobson, Spence, Kerr 2016 \cite{jacobson2016}} und Ron Jeffries\footnote{Vgl. Ron Jeffries \cite{jeffries2022}}.
Mithilfe einfacher Sprache wird aus der Sicht des Stakeholders das Ziel einer Story in einem kurzen Satz zusammengefasst.
Anschließend wird dieses Ziel begründet, um die Wichtigkeit und Existenzberechtigung der Story zu begründen.
User Stories sind dabei auch Anforderungen nach dem SMART Prinzip\footnote{Vgl. Witte 2019a, S. 67 \cite{witte2016}}, da diese nur einen sehr kleinen abgesteckten Teilbereich einer Funktionalität enthalten.
Dadurch sind sie einfacher schätzbar, umsetzbar und testbar. Anhand der ermittelten User Stories werden nach der Entwicklung Akzeptanztests durchgeführt, um den Erfolg des Endproduktes objektiv zu bewerten.

\section{User Stories}
\label{sec:userStories}
Die Anforderungen umfassen alle Aktionen, welche der Nutzer in der Anwendung durchführen will.
Ziel aller Anforderungen ist die übergreifende Suche über mehrere Kategorien effizient anhand mehrerer Kriterien zu durchsuchen und zu bewerten.
Anhand dieses Ziels werden User Stories entwickelt, in denen ein Nutzer und andere Personen ihre Anforderungen an das zu entwickelnde Produkt stellen.

Nichtfunktionale Anforderungen werden bei dieser Anforderungserhebung nicht beachtet, da es sich hierbei um die Erweiterung einer bestehenden \gls{api} handelt und Aspekte wie Benutzerfreundlichkeit und User Experience hierbei wenig relevant sind, bzw. das Entwicklungsumfeld durch die bereits bestehende Anwendung vorgegeben ist.
Die Priorität der einzelnen User Stories ergibt sich aus der unten gegebenen Reihenfolge.

\pagebreak
Ich, als Benutzer, will …
\begin{enumerate}
  \item … für ein gegebenes Suchkriterium relevante Suchergebnisse über mehrere Kategorien hinweg erhalten, damit mit einer einzelnen Suche nur eine geringe Teilmenge der Datenbank angezeigt wird.
  \item … die erhaltenen Suchbegriffe nach Kontext und Wahrscheinlichkeit gewichtet erhalten, damit diese im späteren Verlauf sortiert werden können. Der Kontext ergibt sich aus möglichen Schlagworten, die im Suchbegriff verwendet worden, womit z. B. eine Kategorie, ein Attribut eines Ergebnisses oder höher gewertet wird. Beispiele wären:
    \begin{enumerate}
      \item … der Titel eines Buches wird „relativ“ genau als Suchbegriff eingegeben, folglich wird dieses Buch stärker gewichtet.
      \item … der Suchbegriff enthält den Term „Video“, folglich werden alle Videos priorisiert.
    \end{enumerate}
  \item … die erhaltenen Suchbegriffe anhand des errechneten Gewichts absteigend sortiert zurückgegeben bekommen, damit das relevanteste Suchergebnis auf der Suchergebnisseite ganz oben steht.
  \item … ein ideales Suchergebnis als grafisch hervorgehobenen Vorschlag angezeigt bekommen, damit auf der Suchergebnisseite eine schnelle Navigation zu diesem Ergebnis möglich ist.
    Dabei soll ein Inhalt nur vorgeschlagen werden, wenn dessen Relevanz um einiges höher ist, als das der anderen gefundenen Ergebnisse.
    Dies verhindert, dass von ähnlich relevanten Suchergebnissen eines ohne Berechtigung hervorgehoben wird, auch wenn es das Relevanteste in dieser Liste ist. \footnote{Siehe \ref{fig:tomate}}
\end{enumerate}

Die User Stories 2.a und 3 sind in der Anwendung bereits vorhanden und sind in der aufgeführten Liste nur zur besseren Übersichtlichkeit aufgeführt. Sie sollen nach der Entwicklung der neuen \gls{api} gleich bleiben und nicht verändert werden.
